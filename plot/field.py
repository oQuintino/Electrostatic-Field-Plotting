"""
Author: oQuintino
Description: Electric field computation and visualization utilities for a
             coaxial cylindrical geometry with a dielectric layer.
"""

import math

import numpy as np

import cylinder


class DielectricField:
    """
    Electric field model for a finite-length coaxial cylinder with a dielectric layer.

    This class computes the electric field generated by a coaxial structure
    consisting of:
    - An inner conductor
    - A dielectric region
    - An outer conductor

    The electric field is evaluated on a discretized cylindrical grid and
    returned in Cartesian coordinates.
    """

    eps_0 = 8.854e-12  # Vacuum permittivity [F/m]
    eps_g = eps_0  # Permittivity of the gas region
    eps_d = 5 * eps_0  # Permittivity of the dielectric layer

    r_a = 13.5e-3  # Inner conductor radius [m]
    r_d = 14.8e-3  # Dielectric outer radius [m]
    r_b = 18e-3  # Outer conductor radius [m]

    L = 20e-2  # Cylinder length [m]

    V_0 = 10e3  # Applied voltage [V]

    geometric_factor = eps_g / (
        eps_g * math.log(r_d / r_a) + eps_d * math.log(r_b / r_d)
    )

    coords = cylinder.CoaxialCylinder(r_a, r_b, L)

    def calculate_field(self):
        """
        Compute the electric field inside the coaxial cylinder.

        The electric field is computed assuming axial symmetry and finite
        cylinder length. The analytical expressions correspond to the
        superposition of two finite line charges.

        The field is first calculated in cylindrical coordinates (Er, Ez),
        corrected inside the dielectric region, and then converted to
        Cartesian coordinates.

        Returns
        -------
        points : ndarray of shape (N, 3)
            Cartesian coordinates of the evaluation points.
        vectors_unit : ndarray of shape (N, 3)
            Unit electric field vectors in Cartesian coordinates.
        mag : ndarray of shape (N,)
            Magnitude of the electric field [V/m].
        """

        r, z = self.coords.rz_coordinates

        # Prevent singularities at r = 0
        r_safe = np.maximum(r, 1e-15)

        half_L = self.L / 2

        term1 = (z + half_L) / np.sqrt(r_safe**2 + (z + half_L) ** 2)
        term2 = (z - half_L) / np.sqrt(r_safe**2 + (z - half_L) ** 2)

        axial_factor = (term1 - term2) / 2

        Er = self.V_0 * self.geometric_factor / r_safe * axial_factor

        Ez = (
            self.V_0
            * self.geometric_factor
            * (
                1 / np.sqrt(r_safe**2 + (z - half_L) ** 2)
                - 1 / np.sqrt(r_safe**2 + (z + half_L) ** 2)
            )
        )

        # Dielectric correction (field scaling by permittivity ratio)
        mask_diel = r_safe >= self.r_d
        factor_diel = self.eps_d / self.eps_g

        Er_diel = np.where(mask_diel, Er * factor_diel, Er)
        Ez_diel = np.where(mask_diel, Ez * factor_diel, Ez)

        return self.coords.to_cartesian(Er_diel, Ez_diel)

    def mean_radial_error(self):
        """
        Compute the mean volumetric relative error of the radial electric field
        due to the finite length of the coaxial cylinder.

        The error is defined as:
            Îµ(r, z) = 1 - F(r, z)

        and averaged over the cylindrical volume using the correct geometric
        weight (r dr dz).

        Returns
        -------
        float
            Mean relative error (dimensionless).
        """

        r_a = self.r_a
        r_b = self.r_b
        L = self.L

        numerator = (
            (r_b**2 + L**2) ** (3 / 2) - (r_a**2 + L**2) ** (3 / 2) - (r_b**3 - r_a**3)
        )

        denominator = r_b**2 - r_a**2

        mean_error = 1 - (2 / (3 * L)) * (numerator / denominator)

        return mean_error
